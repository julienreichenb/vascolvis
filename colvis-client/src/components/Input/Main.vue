<template lang="pug">
    section.col-input-main
        col-input-selector(
            v-show="annotating" 
            :init="init" :offsetTop="offsetTop"  :vis="vis"
            :selectedSubjects="selectedSubjects" :selectedComplements="selectedComplements" :step="step"
            @subjectSelection="selectElementsBySelector($event)" @complementSelection="selectElementsBySelector($event, 'complement')"
        )
        col-input-overlay(
            :annotating="annotating" :elements="elements" :previousTags="previousTags"
            :selectedComplements="selectedComplements" :selectedSubjects="selectedSubjects" 
            @close="$emit('close')" @stepChanged="step = $event" @boxSubjectSelection="selectElementsByBox($event)"
            @boxComplementSelection="selectElementsByBox($event, 'complement')" @submittingAnnotation="$emit('submittingAnnotation', $event)"
        )
</template>

<script>
import ColInputSelector from '@/components/Input/Selector.vue';
import ColInputOverlay from '@/components/Input/Overlay.vue';

import { checkIfSelected } from '@/assets/utils';

/**
 * Create a new Colvis.
 * This component manages all data and communication between
 * the other subcomponents (chiefly, the Selector and the Overlay).
 */
export default {
    components: { ColInputOverlay, ColInputSelector },
    props: {
        /** A query selector that identifies the visualization's container */
        vis: { type: String, required: true },
        /** Whether the user is annotating the visualization */
        annotating: { type: Boolean, default: false },
        /** Whether to use the dark theme for the Vuetify's components */
        dark: { type: Boolean, default: false },
        /** Whether the visualization has been initialized */
        init: { type: Boolean, default: false },
        /** The list of existing tags in the backend's database */
        previousTags: { type: Array, default: () => [] },
        /** The list of elements, generated by a call to getDataFromContainer */
        elements: { type: Array, required: true },
        /**
         * The height in pixels of the padding-top of the container.
         * Useful when the Selector lies within elements with position absolute.
         */
        offsetTop: { type: Number, default: 0 }
    },
    data () {
        /** The list of selected subjects */
        const selectedSubjects = [];
        /** The list of selected components */
        const selectedComplements = [];
        /** The current step of the annotation */
        const step = 1;

        return { selectedSubjects, selectedComplements, step };
    },
    methods: {
        /**
         * Select a list of elements, based on the selection's coordinates usually sent from a Selector.
         * @param {SelectionCoordinates} coordinates selected rectangle where to search for selectable elements
         * @param {string} [pool=subject] either 'subject' or 'complement', which pool to feed with the selection
         */
        selectElementsBySelector(coordinates, pool = 'subject') {
            const selectedElements = this.elements.filter((el) => {
                const elRect = el.domElement.getBoundingClientRect();
                return checkIfSelected(elRect, coordinates);
            });

            if (pool === 'subject') this.selectedSubjects = selectedElements;
            else this.selectedComplements = selectedElements;
        },

        /**
         * Select a list of elements.
         * @param {Array} elements a list of elements
         * @param {string} [pool=subject] either 'subject' or 'complement', which pool to feed with the selection
         */
        selectElementsByBox(elements, pool = 'subject') {
            const els = elements.map((el) => el.id);
            const selectedElements = this.elements.filter((el) => {
                return els.includes(el.id);
            });

            if (pool === 'subject') this.selectedSubjects = selectedElements;
            else this.selectedComplements = selectedElements;
        }

    }
}
</script>
